name: Process Submission

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: write

jobs:
  process-submission:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse issue body
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;
            const labels = context.payload.issue.labels.map(l => l.name);

            // Parse the issue form response
            const typeMatch = issueBody.match(/### Type\s*\n\s*([^\n]+)/);
            const urlMatch = issueBody.match(/### Repository URL\s*\n\s*([^\n\s]+)/);

            if (!typeMatch || !urlMatch) {
              core.setFailed('Invalid issue format');
              return;
            }

            const type = typeMatch[1].trim();
            const url = urlMatch[1].trim();

            // Parse GitHub URL to extract owner and repo
            // Support formats: https://github.com/owner/repo or owner/repo
            let owner, repo;
            const githubUrlMatch = url.match(/github\.com\/([^\/]+)\/([^\/\s]+)/);
            if (githubUrlMatch) {
              owner = githubUrlMatch[1];
              repo = githubUrlMatch[2];
            } else {
              const shortMatch = url.match(/^([^\/]+)\/([^\/\s]+)$/);
              if (shortMatch) {
                owner = shortMatch[1];
                repo = shortMatch[2];
              } else {
                core.setFailed('Invalid GitHub URL format');
                return;
              }
            }

            // Remove .git suffix if present
            repo = repo.replace(/\.git$/, '');

            core.setOutput('type', type);
            core.setOutput('repo-url', url);
            core.setOutput('owner', owner);
            core.setOutput('repo', repo);

            console.log(`Type: ${type}`);
            console.log(`URL: ${url}`);
            console.log(`Owner: ${owner}`);
            console.log(`Repo: ${repo}`);
      
      - name: Fetch latest tag
        id: get-tag
        if: steps.parse.outputs.type == 'extension'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = '${{ steps.parse.outputs.owner }}';
            const repo = '${{ steps.parse.outputs.repo }}';

            try {
              // Get all tags
              const { data: tags } = await github.rest.repos.listTags({
                owner: owner,
                repo: repo,
                per_page: 1
              });

              if (tags.length === 0) {
                core.setFailed('No tags found in repository. Please create a release tag first.');
                return;
              }

              const latestTag = tags[0].name;
              core.setOutput('tag', latestTag);
              console.log(`Latest tag: ${latestTag}`);

            } catch (error) {
              core.setFailed(`Failed to fetch tags: ${error.message}`);
            }

      - name: Fetch package.json from latest tag
        id: fetch
        if: steps.parse.outputs.type == 'extension'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = '${{ steps.parse.outputs.owner }}';
            const repo = '${{ steps.parse.outputs.repo }}';
            const tag = '${{ steps.get-tag.outputs.tag }}';
            const repoUrl = '${{ steps.parse.outputs.repo-url }}';

            try {
              // Fetch package.json from the latest tag
              const { data } = await github.rest.repos.getContent({
                owner: owner,
                repo: repo,
                path: 'package.json',
                ref: tag
              });

              const content = Buffer.from(data.content, 'base64').toString('utf-8');
              const packageJson = JSON.parse(content);

              // Extract required fields and add repo URL
              const appData = {
                icon: packageJson.icon,
                name: packageJson.name,
                title: packageJson.title,
                desc: packageJson.desc,
                version: packageJson.version,
                repo: repoUrl
              };

              // Validate required fields
              if (!appData.icon || !appData.name || !appData.title || !appData.desc || !appData.version) {
                core.setFailed('Missing required fields in package.json (icon, name, title, desc, version)');
                return;
              }

              core.setOutput('app-data', JSON.stringify(appData));
              console.log('App data:', JSON.stringify(appData, null, 2));

            } catch (error) {
              core.setFailed(`Failed to fetch package.json from tag ${tag}: ${error.message}`);
            }

      - name: Update app.json
        id: update
        if: steps.parse.outputs.type == 'extension'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const appDataStr = '${{ steps.fetch.outputs.app-data }}';
            const appData = JSON.parse(appDataStr);

            // Read current app.json
            let apps = {};
            try {
              const content = fs.readFileSync('app.json', 'utf-8');
              apps = JSON.parse(content);
            } catch (error) {
              console.log('app.json is empty or invalid, starting fresh');
            }

            // Check for duplicate name
            if (apps[appData.name]) {
              core.setFailed(`Extension with name "${appData.name}" already exists`);

              // Comment on issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **Submission Failed**\n\nAn extension with the name \`${appData.name}\` already exists in the store.\n\nPlease choose a different name and resubmit.`
              });

              // Close issue with label
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed',
                labels: ['duplicate', 'extension']
              });

              return;
            }

            // Add new entry
            apps[appData.name] = appData;

            // Write back to app.json
            fs.writeFileSync('app.json', JSON.stringify(apps, null, 2) + '\n');

            core.setOutput('success', 'true');
            core.setOutput('app-name', appData.name);

      - name: Commit changes
        if: steps.update.outputs.success == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add app.json
          git commit -m "Add extension: ${{ steps.update.outputs.app-name }}" -m "Closes #${{ github.event.issue.number }}"
          git push

      - name: Close issue with success comment
        if: steps.update.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const appName = '${{ steps.update.outputs.app-name }}';

            // Comment on issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚úÖ **Submission Successful**\n\nYour extension \`${appName}\` has been added to the Keyer store!\n\nThank you for your contribution! üéâ`
            });

            // Close issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed',
              labels: ['completed', 'extension']
            });
